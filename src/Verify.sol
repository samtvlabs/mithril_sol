// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

/// @notice This tests to the mithril_stm precompile. We have added the precompile to address 16 ,
/// so the aim of this is to pass the protocol paramters generated by our script to this. It will
/// have to be loaded via assembly since solidity does have have the built-in for this.
contract Verify {
    // This function takes all this parameters , coverts to it a bytes array , call calls a precompile address 16 via assembly, return true or false
    function verify_stm(uint256 m, uint256 k, uint256 phi_f, bytes memory ms, bytes memory msig)
        public
        view
        returns (bool)
    {
        bytes memory input = abi.encode(m, k, phi_f, ms, msig);
        bool result;
        address stm_verify_address = address(16);

        assembly {
            let ptr := mload(0x40)
            mstore(ptr, input)
            let success := staticcall(gas(), stm_verify_address, ptr, mload(input), ptr, 32)

            if iszero(success) { revert(ptr, returndatasize()) }

            result := mload(ptr)
        }

        return result;
    }
}

// pragma solidity ^0.8.0;

// contract Verify {
//     function verify_stm(uint256 m, uint256 k, uint256 phi_f, bytes memory ms, bytes memory msig)
//     public
//     view
//     returns (bool)
//     {
//         bytes memory input = abi.encodePacked(m, k, phi_f, ms, msig);
//         bool result;
//         address stm_verify_address = address(16);

//         assembly {
//         // Allocate and populate memory
//             let ptr := add(0x20, mload(add(input, 0x20)))  // Skip the length field of the bytes array
//             mstore(0x40, add(ptr, 0x20))  // Update the free memory pointer
//             mstore(ptr, mload(add(input, 0x20)))  // Copy the length of the bytes array

//             for { let i := 0 } lt(i, mload(add(input, 0x20))) { i := add(i, 0x20) } {
//                 mstore(add(ptr, add(0x20, i)), mload(add(add(input, 0x40), i)))
//             }

//         // Static call
//             let success := staticcall(gas(), stm_verify_address, add(ptr, 0x20), mload(ptr), ptr, 0x20)

//             if iszero(success) { revert(ptr, returndatasize()) }

//             result := mload(ptr)
//         }

//         return result;
//     }
// }

// pragma solidity ^0.8.17;

// /// @notice This tests to the mithril_stm precompile. We have added the precompile to address 16 ,
// /// so the aim of this is to pass the protocol paramters generated by our script to this. It will
// /// have to be loaded via assembly since solidity does have have the built-in for this.
// contract Verify {
//     // This function takes all this parameters , coverts to it a bytes array , call calls a precompile address 16 via assembly, return true or false
//     function verify_stm(uint256 m, uint256 k, uint256 phi_f, bytes memory ms, bytes memory msig)
//         public
//         view
//         returns (bool)
//     {
//         //not sure if the precompile expects a concatenated bytes or with abi.encode (lets try with both?)
//         bytes memory input = abi.encodePacked(m, k, phi_f, ms, msig);

//         (bool ok, bytes memory out) = address(16).staticcall(input);

//         require(ok, "did not work");

//         return ok;
//     }
// }